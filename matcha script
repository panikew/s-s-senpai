-- Load Arcane Library
local success, errorMsg = pcall(function()
    loadstring(game:HttpGet("https://arcanecheats.xyz/api/matcha/uilib"))()
end)

if not success then
    warn("Error loading Script:", errorMsg)
    return
end

-- Wait for library to load
repeat 
    wait(0.1) 
until Arcane

print("Script loaded successfully!")

-- ==================== WINDOW CREATION ====================
local Window = Arcane:CreateWindow("Blind Shot", Vector2.new(500, 400), "Default")

-- ==================== CATEGORY "HOME" ====================
Window:CreateTabSection("Home")

-- ==================== TAB "CREDITS" ====================
local CreditsTab = Window:CreateTab("Credits")
local CreditsSection = Window:CreateSection("Credits", "Credits")

-- Credits
CreditsSection:AddLabel("Made by panikewww")

-- Add space
CreditsSection:AddLabel(" ")

-- Additional info
CreditsSection:AddLabel("Version: Blind Shot v1.0.0")
CreditsSection:AddLabel("Date: " .. os.date("%d/%m/%Y"))

-- NEW: Web redirect button
CreditsSection:AddButton("Youtube", function()
    print("Opening website...")
    
    -- URL para redirecionamento (substitua pela sua URL)
    local websiteURL = "https://www.youtube.com/@djpiskahvhdestroyerowo"  -- <-- ALTERE AQUI SUA URL
    
    -- Tenta abrir a página web
    local success, error = pcall(function()
        -- Método 1: Usar HTTP Get para abrir (funciona em alguns ambientes)
        local request = syn and syn.request or request
        if request then
            request({
                Url = websiteURL,
                Method = "GET"
            })
            print("Website request sent:", websiteURL)
        else
            -- Método 2: Usar console para mostrar link
            print("\n" .. string.rep("=", 50))
            print("WEBSITE LINK")
            print(string.rep("=", 50))
            print("Copy this URL and open in browser:")
            print(websiteURL)
            print(string.rep("=", 50))
        end
    end)
    
    if not success then
        print("Could not open website automatically")
        print("Please copy this URL manually:")
        print(websiteURL)
    end
    
    if Arcane.Notify then
        Arcane:Notify("Website", 
            "Check console for details", 
            3)
    end
end)

-- Info button
CreditsSection:AddButton("Show Info", function()
    local infoMessage = [[
=== CREDITS ===

Developed by: djpiska

Script included:
Auto Farm (Auto teleport)
ESP (Tracer + Box)
Arcane Interface

Thank you for using my script!]]
    
    print("\n" .. infoMessage)
    
    if Arcane.Notify then
        Arcane:Notify("Credits", 
            "Developed by: djpiska\n" ..
            "", 
            5)
    end
end)

-- ==================== CATEGORY "MAIN" ====================
Window:CreateTabSection("Main")

-- ==================== TAB "AUTO FARM" ====================
local AutoFarmTab = Window:CreateTab("Auto Farm")
local AutoFarmSection = Window:CreateSection("Controls", "Auto Farm")

-- Auto Farm script
local autoFarmActive = false
local teleportToggle = true
local posA = Vector3.new(78.49, 65.00, 116.58)
local posB = Vector3.new(74.29, 65.00, 117.12)

local lp, char, hrp
local function initializeReferences()
    lp = game.Players.LocalPlayer
    char = lp.Character or lp.CharacterAdded:Wait()
    hrp = char:WaitForChild("HumanoidRootPart")
    return hrp ~= nil
end

local autoFarmToggle = AutoFarmSection:AddToggle("Auto Farm", false, function(isActive)
    autoFarmActive = isActive
    if isActive then
        if initializeReferences() then
            setrobloxinput(true)
            print("Auto Farm ON")
            if Arcane.Notify then
                Arcane:Notify("Auto Farm", "Script ON ✓\nF1 to teleport", 3)
            end
        else
            print("Initialization error")
            autoFarmToggle:SetValue(false)
        end
    else
        print("Auto Farm OFF")
        if Arcane.Notify then
            Arcane:Notify("Auto Farm", "Script OFF", 2)
        end
    end
end)

local speedSlider = AutoFarmSection:AddSlider("Speed (seconds)", {
    Min = 0.1,
    Max = 20.0,
    Default = 15.0,
    Callback = function(value)
        print("Speed adjusted:", value, "s")
    end
})

-- ==================== TAB "ESP" ====================
local EspTab = Window:CreateTab("ESP")
local EspSection = Window:CreateSection("Tracer and Box ESP", "ESP")

-- ESP Settings
local SETTINGS = {
    Enabled = false,
    Length = 30,
    Color = Color3.fromRGB(255, 255, 255),
    EnemyColor = Color3.fromRGB(255, 0, 0),
    Thickness = 1.5,
    Transparency = 1.0,
    BoxEnabled = true,
    BoxThickness = 1,
    BoxFilled = false,
    BoxSize = Vector3.new(4, 6, 3),
    RefreshRate = 0.015,
    GracePeriod = 0.05,
    ZIndex = 10,
    WarningThreshold = 0.65
}

-- Main ESP toggle
local espToggle = EspSection:AddToggle("ESP", false, function(isActive)
    SETTINGS.Enabled = isActive
    if isActive then
        print("ESP ON")
        if Arcane.Notify then
            Arcane:Notify("ESP", "ESP Script ON", 3)
        end
    else
        print("ESP OFF")
        if Arcane.Notify then
            Arcane:Notify("ESP", "ESP Script OFF", 2)
        end
    end
end)

-- Configuration sliders
local lengthSlider = EspSection:AddSlider("Tracer Length", {
    Min = 10,
    Max = 100,
    Default = 30,
    Callback = function(value)
        SETTINGS.Length = value
        print("Tracer Length:", value)
    end
})

-- Color pickers
local colorPicker = EspSection:AddColorPicker("Normal Color", SETTINGS.Color, function(color)
    SETTINGS.Color = color
    print("Normal color changed:", color)
end)

local enemyColorPicker = EspSection:AddColorPicker("Alert Color", SETTINGS.EnemyColor, function(color)
    SETTINGS.EnemyColor = color
    print("Alert color changed:", color)
end)

-- Additional toggles
local boxToggle = EspSection:AddToggle("Show Box", SETTINGS.BoxEnabled, function(state)
    SETTINGS.BoxEnabled = state
    print("Box ESP:", state and "ON" or "OFF")
end)

local fillToggle = EspSection:AddToggle("Filled Box", SETTINGS.BoxFilled, function(state)
    SETTINGS.BoxFilled = state
    print("Filled box:", state and "ON" or "OFF")
end)

-- Reset settings button
EspSection:AddButton("Reset Settings", function()
    -- Update SETTINGS
    SETTINGS = {
        Enabled = SETTINGS.Enabled,
        Length = 30,
        Color = Color3.fromRGB(255, 255, 255),
        EnemyColor = Color3.fromRGB(255, 0, 0),
        Thickness = 1.5,
        Transparency = 1.0,
        BoxEnabled = true,
        BoxThickness = 1,
        BoxFilled = false,
        BoxSize = Vector3.new(4, 6, 3),
        RefreshRate = 0.015,
        GracePeriod = 0.05,
        ZIndex = 10,
        WarningThreshold = 0.65
    }
    
    -- Update interface controls
    espToggle:SetValue(SETTINGS.Enabled)
    lengthSlider:SetValue(30)
    colorPicker:SetValue(Color3.fromRGB(255, 255, 255))
    enemyColorPicker:SetValue(Color3.fromRGB(255, 0, 0))
    boxToggle:SetValue(true)
    fillToggle:SetValue(false)
    
    print("ESP settings reset")
    if Arcane.Notify then
        Arcane:Notify("ESP", "Settings reset to default", 3)
    end
end)

-- ==================== ESP Script ====================
local OFFSET_CFRAME = 0xC0
local OFFSET_PRIMITIVE = 0x148

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local TracerData = {}
local ArmCache = {}
local RootCache = {}

local function MemoryWorker(instanceAddress)
    local primitiveAddress = memory_read("uintptr_t", instanceAddress + OFFSET_PRIMITIVE)
    if not primitiveAddress or primitiveAddress == 0 then return nil end

    local r01 = memory_read("float", primitiveAddress + OFFSET_CFRAME + 0x04)
    local r11 = memory_read("float", primitiveAddress + OFFSET_CFRAME + 0x10)
    local r21 = memory_read("float", primitiveAddress + OFFSET_CFRAME + 0x1C)
    
    return r01, r11, r21
end

local function GetRotationComponents(instanceAddress)
    local primitiveAddress = memory_read("uintptr_t", instanceAddress + OFFSET_PRIMITIVE)
    if not primitiveAddress or primitiveAddress == 0 then return nil end

    local cfAddr = primitiveAddress + OFFSET_CFRAME
    
    local r00 = memory_read("float", cfAddr + 0x00)
    local r01 = memory_read("float", cfAddr + 0x04)
    local r02 = memory_read("float", cfAddr + 0x08)
    
    local r10 = memory_read("float", cfAddr + 0x0C)
    local r11 = memory_read("float", cfAddr + 0x10)
    local r12 = memory_read("float", cfAddr + 0x14)
    
    local r20 = memory_read("float", cfAddr + 0x18)
    local r21 = memory_read("float", cfAddr + 0x1C)
    local r22 = memory_read("float", cfAddr + 0x20)

    return {x=r00, y=r10, z=r20}, {x=r01, y=r11, z=r21}, {x=r02, y=r12, z=r22}
end

local function CalculateCorners(pos, size, right, up, back)
    local corners = {}
    local factors = {-0.5, 0.5}

    for _, x in ipairs(factors) do
        for _, y in ipairs(factors) do
            for _, z in ipairs(factors) do
                local dx = x * size.X
                local dy = y * size.Y
                local dz = z * size.Z

                local finalX = pos.X + (right.x * dx) + (up.x * dy) + (back.x * dz)
                local finalY = pos.Y + (right.y * dx) + (up.y * dy) + (back.y * dz)
                local finalZ = pos.Z + (right.z * dx) + (up.z * dy) + (back.z * dz)

                table.insert(corners, Vector3.new(finalX, finalY, finalZ))
            end
        end
    end

    return corners
end

local function GetScreenBoundingBox(corners)
    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local anyVisible = false

    for _, corner in ipairs(corners) do
        local screenPos, onScreen = WorldToScreen(corner)
        
        if onScreen then
            anyVisible = true
        end
        
        if screenPos.X < minX then minX = screenPos.X end
        if screenPos.Y < minY then minY = screenPos.Y end
        
        if screenPos.X > maxX then maxX = screenPos.X end
        if screenPos.Y > maxY then maxY = screenPos.Y end
    end

    if not anyVisible then return nil end

    return minX, minY, maxX, maxY
end

local function GetDownVectorFromMemory(instanceAddress)
    if not instanceAddress or instanceAddress == 0 then return nil end

    local success, r01, r11, r21 = pcall(MemoryWorker, instanceAddress)

    if not success or not r01 or not r11 or not r21 then
        return nil
    end

    return Vector3.new(-r01, -r11, -r21)
end

local function CreateTracerEntry(playerName, playerInstance)
    if TracerData[playerName] then return TracerData[playerName] end

    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = SETTINGS.Color
    line.Thickness = SETTINGS.Thickness
    line.Transparency = SETTINGS.Transparency
    line.ZIndex = SETTINGS.ZIndex
    
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = SETTINGS.Color
    box.Thickness = SETTINGS.BoxThickness
    box.Filled = SETTINGS.BoxFilled
    box.Transparency = SETTINGS.Transparency
    box.ZIndex = SETTINGS.ZIndex

    local entry = {
        Line = line,
        Box = box,
        LastUpdate = 0,
        PlayerInstance = playerInstance
    }
    
    TracerData[playerName] = entry
    return entry
end

local function RemoveTracer(playerName)
    local entry = TracerData[playerName]
    if entry then
        if entry.Line then entry.Line:Remove() end
        if entry.Box then entry.Box:Remove() end
        
        if entry.PlayerInstance then
            ArmCache[entry.PlayerInstance] = nil
            RootCache[entry.PlayerInstance] = nil
        end
        TracerData[playerName] = nil
    end
end

local function FindArm(character)
    if not character then return nil end
    local arm = character:FindFirstChild("Right Arm")
    if not arm then
        arm = character:FindFirstChild("RightHand")
    end
    return arm
end

local function FindRoot(character)
    if not character then return nil end
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then
        root = character:FindFirstChild("Torso")
    end
    return root
end

local function UpdateTracers()
    local currentPlayers = Players:GetChildren()
    local activePlayerNames = {} 
    
    local camera = workspace.CurrentCamera
    if not camera then return end

    local camPos = camera.Position 

    for _, player in pairs(currentPlayers) do
        if player.ClassName == "Player" then
            local pName = player.Name
            activePlayerNames[pName] = true 
            
            if player ~= LocalPlayer and pName ~= LocalPlayer.Name then
                local shouldDrawLine = false
                local shouldDrawBox = false
                
                local entry = TracerData[pName] or CreateTracerEntry(pName, player)
                local line = entry.Line
                local box = entry.Box

                if player.Character then
                    local arm = ArmCache[player]
                    if not arm or arm.Parent ~= player.Character then
                        arm = FindArm(player.Character)
                        ArmCache[player] = arm
                    end
                    
                    local root = RootCache[player]
                    if not root or root.Parent ~= player.Character then
                        root = FindRoot(player.Character)
                        RootCache[player] = root
                    end

                    local lookVec = nil
                    local armPos = nil
                    local rootPos = nil
                    local boxSize = nil
                    
                    if arm and arm.Address ~= 0 then
                        lookVec = GetDownVectorFromMemory(arm.Address)
                        armPos = arm.Position
                    end
                    
                    if root and root.Address ~= 0 then
                        rootPos = root.Position
                        boxSize = SETTINGS.BoxSize 
                    end

                    if lookVec and armPos then
                        local endX = armPos.X + (lookVec.X * SETTINGS.Length)
                        local endY = armPos.Y + (lookVec.Y * SETTINGS.Length)
                        local endZ = armPos.Z + (lookVec.Z * SETTINGS.Length)
                        local endPos = Vector3.new(endX, endY, endZ)

                        local screenStart, onScreenStart = WorldToScreen(armPos)
                        local screenEnd, onScreenEnd = WorldToScreen(endPos)

                        if onScreenStart and onScreenEnd then
                            line.From = screenStart
                            line.To = screenEnd
                            shouldDrawLine = true
                        end
                    end
                    
                    if rootPos and boxSize and SETTINGS.BoxEnabled then
                        local success, right, up, back = pcall(GetRotationComponents, root.Address)
                        
                        if success and right and up and back then
                            local corners = CalculateCorners(rootPos, boxSize, right, up, back)
                            
                            local minX, minY, maxX, maxY = GetScreenBoundingBox(corners)
                            
                            if minX then
                                local boxW = maxX - minX
                                local boxH = maxY - minY
                                
                                box.Size = Vector2.new(boxW, boxH)
                                box.Position = Vector2.new(minX, minY)
                                shouldDrawBox = true
                            end
                        end
                    end

                    if (shouldDrawLine or shouldDrawBox) and lookVec and armPos then
                         local diffX = camPos.X - armPos.X
                         local diffY = camPos.Y - armPos.Y
                         local diffZ = camPos.Z - armPos.Z
                         
                         local dist = math.sqrt(diffX*diffX + diffY*diffY + diffZ*diffZ)
                         
                         if dist > 0 then
                             local dirX = diffX / dist
                             local dirY = diffY / dist
                             local dirZ = diffZ / dist
                             
                             local lvX, lvY, lvZ = lookVec.X, lookVec.Y, lookVec.Z
                             local lvMag = math.sqrt(lvX*lvX + lvY*lvY + lvZ*lvZ)
                             if lvMag > 0 then
                                 lvX = lvX / lvMag
                                 lvY = lvY / lvMag
                                 lvZ = lvZ / lvMag
                             end

                             local dot = (dirX * lvX) + (dirY * lvY) + (dirZ * lvZ)
                             
                             if dot > SETTINGS.WarningThreshold then
                                 line.Color = SETTINGS.EnemyColor
                                 box.Color = SETTINGS.EnemyColor
                             else
                                 line.Color = SETTINGS.Color
                                 box.Color = SETTINGS.Color
                             end
                         end
                         
                         entry.LastUpdate = os.clock()
                    end
                else
                    ArmCache[player] = nil
                    RootCache[player] = nil
                    shouldDrawLine = false
                    shouldDrawBox = false
                end

                if shouldDrawLine then
                    if not line.Visible then line.Visible = true end
                else
                    local timeSinceLastUpdate = os.clock() - entry.LastUpdate
                    if timeSinceLastUpdate > SETTINGS.GracePeriod then
                        if line.Visible then line.Visible = false end
                    end
                end
                
                if shouldDrawBox then
                    if not box.Visible then box.Visible = true end
                else
                    local timeSinceLastUpdate = os.clock() - entry.LastUpdate
                    if timeSinceLastUpdate > SETTINGS.GracePeriod then
                        if box.Visible then box.Visible = false end
                    end
                end
            end
        end
    end

    for pName, _ in pairs(TracerData) do
        if not activePlayerNames[pName] then
            RemoveTracer(pName)
        end
    end
end

-- Initialize ESP Script in background
spawn(function()
    print("Tracer and Box ESP Script loaded")
    
    while true do
        local status, err = pcall(function()
            if SETTINGS.Enabled then
                UpdateTracers()
            else
                for _, entry in pairs(TracerData) do
                    if entry.Line and entry.Line.Visible then 
                        entry.Line.Visible = false 
                    end
                    if entry.Box and entry.Box.Visible then 
                        entry.Box.Visible = false 
                    end
                end
            end
        end)

        if not status then
            warn("ESP Error: " .. tostring(err))
        end

        wait(SETTINGS.RefreshRate)
    end
end)

-- ==================== FINALIZATION ====================
Window:Finalize()

print("\n" .. string.rep("=", 50))
print("   Blind shot v1.0.0 - Script")
print(string.rep("=", 50))
print("Categories: Home, Main")
print("Tabs: Credits, Auto Farm, ESP")
print("Auto Farm: F1 to teleport")
print("ESP: Tracer + Box configurable")
print("New: Website button in Credits")

-- Initial notification
if Arcane.Notify then
    Arcane:Notify("Blind Shot v1.0.0", 
        "Script loaded successfully!\n\n" ..
        "Home > Credits:\n" ..
        "• Made by panikewww\n" ..
        "• Thanks to tsarbomb\n" ..
        "• Website button available\n\n" ..
        "Controls:\n" ..
        "• F1 = Toggle teleport\n" ..
        "• Delete = Toggle menu", 
        6)
end

-- ==================== AUTO FARM Script ====================
spawn(function()
    while true do
        if autoFarmActive and hrp then
            if teleportToggle then
                hrp.Position = posA
            else
                hrp.Position = posB
            end
            wait(speedSlider:GetValue() or 0.3)
        else
            wait(0.1)
        end
    end
end)

spawn(function()
    while true do
        if iskeypressed and iskeypressed(0x70) then -- F1
            if autoFarmActive and hrp then
                teleportToggle = not teleportToggle
                local posText = teleportToggle and "A" or "B"
                print("F1: Teleport toggled to Position", posText)
                
                if Arcane.Notify then
                    Arcane:Notify("Teleport", 
                        "Position " .. posText, 
                        1.5)
                end
            end
            wait(0.5)
        end
        wait(0.05)
    end
end)

print("\n Complete Script operational")
